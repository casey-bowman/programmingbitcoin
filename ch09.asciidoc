= Programming Bitcoin
:imagesdir: images

[[chapter_blocks]]
== Blocks

[.lead]
Transactions transfer bitcoins from one party to another and are authorized by signatures. This ensures that the sender authorized the transaction, but what if the sender sends the same coins to multiple people? This is called the double-spending problem and is so called because the owner of a lockbox may try to spend the same output twice. Much like being given a check that has the possibility of bouncing, the receiver needs to be assured that the transaction is valid.

This is where a major innovation of Bitcoin comes in with Blocks. Think of Blocks as a way to order transactions. If we order transactions, a double-spend can be prevented by making any later, conflicting transaction invalid. This would be the equivalent to accepting the first transaction that comes in as the valid one.

It would be really easy to implement this rule (first transaction is valid, subsequent transactions that conflict are invalid) if we could order transactions one at a time, but that would require everyone to agree on which transaction is supposed to be next and would cause a lot of transmission overhead in coming to consensus. We can also order large batches of transactions, maybe once per day, but that wouldn't be very practical as the transactions would settle only once per day and not have any finality before then.

Bitcoin finds a middle ground between these extremes by settling every 10 minutes in batches of transactions. These batches of transactions are what we call Blocks. In this chapter we'll go through how to parse them and how to check what's called the proof-of-work. We'll start with a very special transaction called the Coinbase transaction which is the first transaction of every block.

=== Coinbase Transactions

Coinbase transactions have nothing to do with the company of the same name based in the US. Coinbase is a type of transaction and is the only transaction that's allowed to bring new coins into existence. The Coinbase transaction is the first transaction of every block and is required to exist in every block. This transaction's outputs are kept by whomever the mining entity designates and include all the transaction fees of the other transactions in the block as well as something called the block reward.

Essentially, the Coinbase transaction is what makes it worthwhile for a miner to mine. Here's what a Coinbase transaction looks like:

.Coinbase Transaction
image::coinbase1.png[Coinbase Transaction]

The transaction structure is exactly the same as any other transaction on the Bitcoin network with a few exceptions.

First, by rule, Coinbase Transactions must have exactly one input. Second, that input must have a previous transaction of 32 bytes of `00`. Third, the input must have a previous index of `ffffffff`.

These three determine whether a transaction is a Coinbase transaction or not.

include::code-ch09/answers.py[tag=exercise1]

==== ScriptSig

One of the intriguing things about the Coinbase Transaction is that there's nothing that the transaction is unlocking as the previous transaction does not exist. So what's in there? What information is in there?

It turns out that the ScriptSig of the Coinbase transaction is set by miners. The main restriction is that it has to be at least 2 bytes and no longer than 100 bytes. Other than those restrictions and BIP0034 (see more below) this field can be whatever the miner wants as long as the evaluation of the ScriptSig by itself, with no corresponding ScriptPubKey, evaluates to true. Here is the ScriptSig for the Genesis Block's Coinbase Transaction:

```
4d04ffff001d0104455468652054696d65732030332f4a616e2f32303039204368616e63656c6c
6f72206f6e206272696e6b206f66207365636f6e64206261696c6f757420666f722062616e6b73
```

This ScriptSig was composed by Satoshi and contains a message that we can take a look at:

[source,python]
----
include::code-ch09/examples.py[tag=example1]
----

This was the headline from The Times newspaper on January 3, 2009. This proves that the Genesis Block was created some time _at or after_ that date, and not _before_. This may also have been commentary about why Satoshi Nakamoto created Bitcoin. As you can see, the Coinbase Transaction's ScriptSig can contain arbitrary data.

==== BIP0034

One of the rules for a Coinbase Transaction was added in BIP0034. This was due to a network problem where miners were using the _same_ Coinbase Transaction for different blocks. This was possible in the early days as the 32-bit nonce space was enough to mine blocks and is possible today if extra bits from the version field are used.

The Coinbase Transaction being the same byte-wise means that the transaction ID is also the same since the hash256 of the transaction is deterministic. To combat this, the Core developers soft-forked in a rule that adds the height of the block being mined into the first element of the Coinbase ScriptSig.

The height is interpreted as a Little-Endian integer and must equal the height of the block (that is, the number of blocks since the Genesis Block). Here's how we can parse the height from the Coinbase Transaction in Figure 9-1:

[source,python]
----
include::code-ch09/examples.py[tag=example2]
----

We now know which block the transaction was supposed to be in! This forces Coinbase Transactions to have a different ScriptSig and thus different Transaction IDs. This rule continues to be needed as optimizations like ASICBoost allow the possibility of the same Coinbase Transaction IDs across multiple blocks if BIP0034 wasn't a rule.

include::code-ch09/answers.py[tag=exercise2]

=== Headers vs Full Blocks

Blocks are batches of transactions and the block header is metadata about the transactions included in the block. The block header consists of:

* Version
* Previous Block
* Merkle Root
* Timestamp
* Bits
* Nonce

.Parsed Block
image::block1.png[Block Parsing]

This is the metadata for every block. Unlike transactions, each field in a block headers is of a fixed length. Version is 4 bytes, Previous Block is 32 bytes, Merkle Root is 32 bytes, Timestamp is 4 bytes, Bits is 4 bytes and Nonce is 4 bytes. The headers therefore, take up exactly 80 bytes for each block. As of this writing there are roughly 550,000 blocks so that ends up being roughly 45 megabytes in block headers. The entire blockchain, on the other hand, is roughly 200 GB, so the headers are roughly .023% of the size. This ends up becoming an important design consideration when we look at Simplified Payment Verification in <<chapter_spv>>.

The ID of the block is once again the hash256 of just the header. The hash256 of this block is interesting:

[source,python]
----
include::code-ch09/examples.py[tag=example3]
----

This ID is what gets put into prev_block for a block building on top of this one. For now, notice that the ID has a lot of 0's at the end. We'll come back to this in the proof-of-work section below.

We can start coding a `Block` class based on what we already know:

[source,python]
----
include::code-ch09/block.py[tag=source1]
----

include::code-ch09/answers.py[tag=exercise3]

include::code-ch09/answers.py[tag=exercise4]

include::code-ch09/answers.py[tag=exercise5]

=== Version

Version in normal software refers to a particular set of features. For a block, this is similar, in the sense that the version field reflects what capabilities the software that produced the block is ready for. In the past this was used as a way to indicate a single feature that was ready to be deployed by the miner who mined the block. Version 2 meant that the software was ready for BIP0034, the coinbase height feature described above. Version 3 meant that the software was ready for BIP0066, the enforcement of strict DER encoding. Version 4 meant that the software was ready for BIP0065, which specified `OP_CHECKLOCKTIMEVERIFY`.

Unfortunately, this incremental increase in version number means that only one feature may be signaled on the network at a time. To alleviate this, the developers came up with BIP9, which allows up to 29 different features to be signaled at the same time.

==== BIP9

The way BIP9 works is by fixing the first 3 bits of the 4-byte (32-bit) header to be `001` to indicate that the miner is using BIP9. The first 3 bits have to be `001` as that forces older clients to interpret the version field as a number greater than 4, which was the last version number that was used pre-BIP9.

This means that in hexadecimal, the first character will always be 2 or 3. The other 29 bits can be assigned to different soft-fork features which miners can signal readiness for. For example, bit 0 (the rightmost bit) can be flipped to 1 to signal readiness for one soft fork, bit 1 (the second bit from the right) can be flipped to 1 to signal readiness for another, bit 2 (the third bit from the right) can be flipped to 1 to signal readiness for another and so on.

BIP9 requires that 95% of blocks signal readiness in a given 2016 block epoch before the soft fork feature gets activated on the network. Soft forks which used BIP9 as of this writing have been BIP68/BIP112/BIP113 (`OP_CHECKSEQUENCEVERIFY` and related changes), BIP141 (segwit) and BIP91 (reducing threshold for segwit). These BIPs used bits 0, 1 and 4 for signaling respectively. BIP91 was a little bit of a cheat in that it used an 80% threshold and used a smaller block period.

Checking for these features is relatively straightforward:

[source,python]
----
include::code-ch09/examples.py[tag=example4]
----
<1> The `>>` operator is the left bit-shift operator, which essentially throws away the rightmost 29 bits, leaving just the top 3 bits. The `0b001` is a way of writing a number in binary format in Python.
<2> The `&` operator is the "bitwise and" operator. In our case, we right-shift by 4 bits first and then check that the rightmost bit is actually 1.
<3> We shift 1 to the right because BIP141 was assigned to bit 1.

include::code-ch09/answers.py[tag=exercise6]

include::code-ch09/answers.py[tag=exercise7]

include::code-ch09/answers.py[tag=exercise8]

=== Previous Block

All blocks have to point to a previous block. This is why the data structure is called a _blockchain_. Blocks link back all the way to what we call the Genesis Block. We will note here that the previous block field ends in a bunch of `00` bytes, which we discuss more during the proof-of-work section.

=== Merkle Root

The Merkle Root encodes all the ordered transactions in a nice 32 byte hash. We will discuss how this is important for SPV (simplified payment verification) clients and how they can use the merkle root along with data from the server to get a proof-of-inclusion in <<chapter_spv>>.

=== Timestamp

The timestamp is a unix-style timestamp taking up 4 bytes. Unix timestamps are simply the number of seconds since January 1, 1970. This timestamp is used in two places. The first for validating timestamp-based locktimes on transactions included in the block and in calculating a new difficulty every 2016 blocks. The locktimes used to be used directly for transactions within a block, but BIP113 changed the behavior to not use the current block's locktime directly, but the median-time-past (MTP) of the past 11 blocks.

[NOTE]
.Will Bitcoin overflow on the timestamp?
====
Bitcoin's timestamp field in the block header is 32 bits. This means that once the unix timestamp exceeds 2^32^-1, we will go back to 0. 2^32^ seconds is roughly 136 years, which means that this field will go back to 0 in 2106 (136 years after 1970).

Many people mistakenly believe that we only have until 68 years after 1970, or 2038, but that's only when the field is a signed integer (2^31^ seconds is 68 years), so we get the benefit of that extra bit, giving us until 2106.

In 2106, the block header will need some sort of fork as the timestamp in the block header will no longer continuously increase (due to being reset to 0).
====

=== Bits

Bits is a field that encodes the amount of work necessary in this block. This will be discussed more in the proof-of-work section below.

=== Nonce

Nonce stands for "number used only once" or n-once. This number is what is changed by miners when looking for proof-of-work.

=== Proof-of-work

Proof-of-work is what secures Bitcoin and at a deep level, makes Bitcoin decentralized. Among other things, finding a proof-of-work gives a miner the right to put the attached block into the blockchain. As proof-of-work is very rare, this is not an easy task. But because proof-of-work is objective and easy to verify anyone can be a miner if they so choose.

Proof-of-work is called "mining" for a very good reason. Like physical mining, there is something that miners are searching for. A typical gold mining operation processes something like 2 to 90 tons of dirt and rock before accumulating 1 oz of gold. This is because gold is very rare. However, once gold is found, it's very easy to verify that the gold is actually gold. There are chemical tests, touchstones and many other ways to tell relatively cheaply whether the thing found is gold.

Similarly, proof-of-work is a very rare number that provides an extraordinary result. To find a proof-of-work, the miners on the Bitcoin network have to churn through the numerical equivalent of dirt and rock to find that proof-of-work. Like gold, verifying proof-of-work is much cheaper than actually finding it.

So what is the actual proof-of-work? Let's look at the hash256 of the block we saw before to find out:

```
020000208ec39428b17323fa0ddec8e887b4a7c53b8c0a0a220cfd000000000000000000
5b0750fce0a889502d40508d39576821155e9c9e3f5c3157f961db38fd8b25be1e77a759
e93c0118a4ffd71d
```

[source,python]
----
include::code-ch09/examples.py[tag=example5]
----
<1> We are purposefully printing this number as 64 hexadecimal digits to show how small it is in 256-bit terms.

We can calculate the probability of any random 256-bit number being this small. The probability of the first bit in a 256-bit number being 0 is 0.5. The first two bits being 00, 0.25. The first three bits being 000, 0.125 and so on. Note that each 0 in the hexadecimal above represents 4 0-bits. In this case, we have the first 73 bits being 0, which is 0.5^73^ or about 1 in 10^22^. This is a really tiny probability. You have to look at on average 10^22^ or 10 trillion trillion random 256-bit numbers before you find one this small.

Hash functions like hash256 have the property that the result is more or less random. Since we used hash256 as the hash function to get the block hash, another way to look at this number is to say that we need to calculate 10^22^ hashes on average to find one this small. In other words, the process of finding proof-of-work requires us to process around 10^22^ numerical dirt and rock to find our numerical gold nugget.

==== How a miner generates new hashes

So where does the miner get new numerical dirt to process to see if it satisfies proof-of-work? This is where the nonce field comes in. The miners can change the nonce field at will.

Unfortunately, the 4 bytes or 32-bits, or 2^32^ possible nonces that a miner can try is insufficient space. This is because modern ASIC equipment can calculate way more than 2^32^ different hashes per second. The AntMiner S9, for example, calculates 12 Th/s, or 12,000,000,000,000 hashes per second. That is approximately 2^43^ hashes per second which means that the entire nonce space can be consumed in just 0.0003 seconds.

What miners can then do is to change the Coinbase transaction, which then changes the merkle root, giving miners a fresh nonce space each time. The other option is to roll the version field or overt ASICBOOST. The mechanics of how the Merkle Root changes whenever any transaction in the block changes will be discussed in <<chapter_spv>>.

==== Target

Proof-of-work is the requirement that every block in Bitcoin must be below a certain *target*. Target is a 256-bit number that is computed directly from the bits field. The target is very small compared to an average 256-bit number.

`e93c0118`

The bits field is actually two different numbers. The first is the exponent, which is the last byte. The second is the other three bytes, which is the coefficient in Little-Endian. The formula for calculating the target from these two numbers is:

target = coefficient * 256^exponent-3^

Let's calculate the target given the bits field in Python:

[source,python]
----
include::code-ch09/examples.py[tag=example6]
----
<1> We are purposefully printing this number as 64 hexadecimal digits to show how small it is in 256-bit terms.

A valid proof-of-work is a hash of the block which, when interpreted as a Little-Endian integer, is below the target number. Proof-of-work hashes are exceedingly rare and the process of mining is essentially the process of finding one of these hashes. To find a single proof-of-work with the above target, the network as a whole must calculate 3.8 * 10^21^ hashes. To give this number some context, the best GPU miner in the world would need to run for 50,000 years on average to find a single proof-of-work below this target.

We can check that this block's hash is indeed below the target:

[source,python]
----
include::code-ch09/examples.py[tag=example7]
----
<1> `target` is calculated above.

We can see that the proof-of-work is lower by lining up the numbers in 64 hex characters:

`Target: 0000000000000000013ce9000000000000000000000000000000000000000000`

`ProofW: 0000000000000000007e9e4c586439b0cdbe13b1370bdd9435d76a644d047523`

include::code-ch09/answers.py[tag=exercise9]

==== Difficulty

Target is hard to comprehend for human beings. We know that this is the number that the hash must be below, but as humans, it's hard to fathom the difference between a 180-bit number and a 190-bit number. The first is a thousand times smaller, but from looking at targets, such large numbers are not easy to contextualize.

To make different targets easier to compare, the concept of difficulty was born. Essentialy, difficulty is inversely proportional to target to make comparisons easier. The specific formula is:

difficulty = 0xffff * 256^0x1d-3^ / target

We can code this in python like so:

[source,python]
----
include::code-ch09/examples.py[tag=example8]
----

The difficulty of Bitcoin at the Genesis Block was 1. This gives us context for how difficult mainnet currently is. The difficulty can be thought of as how much more difficult mining is now than it was at the start. The mining difficulty in the above code is roughly 888 billion times more difficult than when Bitcoin started.

This is the number that gets shown in block explorers and Bitcoin price charting services. Difficulty is a much more intuitive way to understand what's going on in terms of effort required to create a new block.

include::code-ch09/answers.py[tag=exercise10]

==== Checking that the Proof-of-Work is Sufficient

We already learned that proof-of-work can be calculated by computing the hash256 of the block header and interpreting this as a Little-Endian integer. If this number is lower than the target, we have a valid proof-of-work. If not, the block is not valid as it doesn't have proof-of-work.

include::code-ch09/answers.py[tag=exercise11]

=== Difficulty Adjustment

In Bitcoin, each group of 2016 blocks is called a _difficulty adjustment period_. At the end of every difficulty adjustment period, the target is adjusted according to this formula:

`time_differential = (block timestamp of last block in difficulty adjustment period) -
(block timestamp of first block in difficulty adjustment period)`

`new_target = previous_target * time_differential / (2 weeks)`

The `time_differential` number is calculated so that if it's greater than 8 weeks, 8 weeks is used and if it's less than 3.5 days, 3.5 days is used. This way, the new target cannot change more than 4x in either direction. That is, the target will be reduced or increased by 4x at the most.

If each block took on average 10 minutes, 2016 blocks should take 20160 minutes. There are 1440 minutes per day, which means that 2016 blocks take 20160 / 1440 = 14 days. We should be calculating how long the last 2016 blocks took by using the timestamp field of the last block of each of the current and previous difficulty adjustment periods. Satoshi unfortunately had another off-by-one error here, as the timestamp differential calculation looks at the first and last blocks of the 2016 block difficulty adjustment period instead. This means that the time_differential ends up being the difference of blocks that are 2015 blocks apart instead of 2016 blocks apart.

We can code this formula like so:

[source,python]
----
include::code-ch09/examples.py[tag=example9]
----
<1> Note that `TWO_WEEKS = 60*60*24*14` is the number of seconds in 2 weeks. 60 seconds times 60 minutes times 24 hours times 14 days.
<2> This makes sure that if it took more than 8 weeks to find the last 2015 blocks, we don't decrease the difficulty too much.
<3> This part makes sure that if it took less than 3.5 days to find the last 2015 blocks, we don't increase the difficulty too much.

Note that you only need the headers to calculate what the next block's target should be. Once we have the target, we can convert target to bits. The inverse operation looks like this:

[source,python]
----
include::code-ch09/helper.py[tag=source1]
----
<1> Get rid of all the leading 0's.
<2> The bits format is a way to express really large numbers succinctly and can be used with both negative and positive numbers. If the first bit in the coefficient is a 1, the bits field is interpreted as a negative number. Since target is always positive for us, we shift everything over by 1 byte if the first bit is 1.
<3> The exponent is how long the number is in base-256.
<4> The coefficient is the first 3 digits of the base-256 number.
<5> We end up truncating the number after the first 3 digits of the base-256 number in case the first bit is 0, the number after the first 2 digits if the first bit is 1.

If the block doesn't have the correct bits calculated using the difficulty adjustment formula, then we can safely reject that block.

include::code-ch09/answers.py[tag=exercise12]

include::code-ch09/answers.py[tag=exercise13]

=== Conclusion

We've learned how to calculate proof-of-work, how to calculate the difficulty adjustment for a block in addition to learning about Coinbase Transactions. We'll now move onto networking on our way to the one field we haven't really covered, which is the merkle root in the next chapter.

